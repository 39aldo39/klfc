{-# LANGUAGE UnicodeSyntax, NoImplicitPrelude #-}

module Xkb.XCompose where

import BasePrelude
import Prelude.Unicode
import Data.Monoid.Unicode ((⊕))
import Util (ifNonEmpty, escape, privateChars, versionStr)

import Control.Monad.State (evalState)
import Control.Monad.Writer (runWriter)
import Lens.Micro.Platform (view, over, _1)

import Layout.Key (setNullChar)
import Layout.Types
import Xkb.Symbols (printLetter)

printXCompose ∷ Layout → Maybe String
printXCompose =
    over _keys (flip evalState privateChars ∘ (traverse ∘ _letters ∘ traverse) setNullChar) >>> \layout → do
    let body = ifNonEmpty ([]:) (printLigatures layout) ⧺ printCustomDeadKeys layout
    guard (not (null body))
    pure ∘ unlines $
        [ "# Generated by KLFC " ⊕ versionStr
        , "# https://github.com/39aldo39/klfc"
        ] ⧺ body

printLigatures ∷ Layout → [String]
printLigatures = concatMap (mapMaybe printLigature ∘ view _letters) ∘ view _keys

printLigature ∷ Letter → Maybe String
printLigature (Ligature (Just c) xs) = Just (printCombination [c] xs)
printLigature _ = Nothing

printCustomDeadKeys ∷ Layout → [String]
printCustomDeadKeys = concatMap (concatMap printCustomDeadKey ∘ view _letters) ∘ view _keys

printCustomDeadKey ∷ Letter → [String]
printCustomDeadKey (CustomDead _ (DeadKey name (Just c) lMap)) =
    [] : "# Dead key: " ⊕ name : printCombinations (map (over _1 (c :)) lMap)
printCustomDeadKey _ = []

printCombinations ∷ [([Char], String)] → [String]
printCombinations = map (uncurry printCombination)

printCombination ∷ [Char] → String → String
printCombination xs s = concatMap (\c → "<" ⊕ printKeysym c ⊕ "> ") xs ⊕ ": " ⊕ escape s
  where printKeysym = fst ∘ runWriter ∘ printLetter ∘ Char
